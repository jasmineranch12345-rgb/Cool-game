<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>Arena Shooter V10.5</title>
<style>
  :root{--bg:#0c0c0f;}
  html,body{height:100%;margin:0;background:var(--bg);-webkit-user-select:none;user-select:none;touch-action:none;}
  canvas{display:block;background:transparent;}
  #ui{
    position:fixed;inset:0;pointer-events:none;font-family:Segoe UI,Roboto,Arial;color:#fff
  }
  #health-bar{position:absolute;left:16px;top:14px;width:220px;height:20px;border:2px solid rgba(255,255,255,0.9);background:#222;pointer-events:auto}
  #health-fill{height:100%;width:100%;background:linear-gradient(90deg,#5ee07a,#37b24d);transition:width .12s linear;}
  #score{position:absolute;left:16px;top:44px;font-size:18px;pointer-events:auto}
  #timer{position:absolute;left:16px;top:70px;font-size:18px;pointer-events:auto}
  #gun{position:absolute;left:16px;top:96px;font-size:16px;opacity:.95;pointer-events:auto}
  #minimap{position:absolute;right:16px;top:14px;width:160px;height:110px;border:2px solid rgba(255,255,255,0.9);background:rgba(0,0,0,0.45);pointer-events:auto}
  #pauseBtn{position:absolute;left:50%;top:14px;transform:translateX(-50%);pointer-events:auto;background:#222;color:#fff;border:1px solid #444;border-radius:10px;padding:8px 14px;font-size:16px}
  #menu,#gameover{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);color:white;z-index:40;font-size:18px;padding:20px;box-sizing:border-box}
  .menu-panel{max-width:720px;width:100%;text-align:center}
  .big-btn{display:inline-block;margin:12px;padding:12px 20px;background:#222;color:white;border-radius:10px;border:1px solid #444;font-size:18px;pointer-events:auto}
  .legend{display:flex;flex-wrap:wrap;justify-content:center;margin-top:12px;gap:8px}
  .legend-item{background:#1a1a1a;padding:6px 10px;border-radius:8px;display:flex;align-items:center;gap:8px}
  .legend-emoji{font-size:18px}
  .js-visual{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:30}
  .js-circle{position:absolute;border-radius:999px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.06);width:100px;height:100px;transform:translate(-50%,-50%);display:flex;align-items:center;justify-content:center}
  .js-knob{width:46px;height:46px;border-radius:999px;background:rgba(255,255,255,0.12)}
  @media (orientation:portrait){#minimap{width:120px;height:90px}}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="ui">
  <div id="health-bar"><div id="health-fill"></div></div>
  <div id="score">Score: 0</div>
  <div id="timer"></div>
  <div id="gun">Gun: Pistol</div>
  <canvas id="minimap"></canvas>
  <button id="pauseBtn">Pause</button>
</div>

<div id="menu">
  <div class="menu-panel">
    <h1>Arena Shooter ‚Äî V10.5</h1>
    <div style="margin:10px 0">Left joystick = move ¬∑ Right joystick = aim & shoot</div>
    <div style="margin:14px 0">
      <button class="big-btn" onclick="startGame('survival')">Start Survival</button>
      <button class="big-btn" onclick="startGame('time')">Start Time Attack</button>
    </div>

    <div style="margin-top:10px">Pickups:</div>
    <div class="legend">
      <div class="legend-item"><div class="legend-emoji">üî´</div><div>Pistol (default)</div></div>
      <div class="legend-item"><div class="legend-emoji">üü£</div><div>Shotgun</div></div>
      <div class="legend-item"><div class="legend-emoji">üîµ</div><div>Rifle</div></div>
      <div class="legend-item"><div class="legend-emoji">üü•</div><div>Rocket</div></div>
    </div>

    <div style="margin-top:10px">Power-ups:</div>
    <div class="legend">
      <div class="legend-item"><div class="legend-emoji">‚ö°</div><div>Rapid Fire</div></div>
      <div class="legend-item"><div class="legend-emoji">üõ°</div><div>Shield</div></div>
      <div class="legend-item"><div class="legend-emoji">üíñ</div><div>Heal</div></div>
      <div class="legend-item"><div class="legend-emoji">‚ú¶</div><div>Double Points</div></div>
      <div class="legend-item"><div class="legend-emoji">üèÉ</div><div>Speed</div></div>
      <div class="legend-item"><div class="legend-emoji">üí•</div><div>Explosive</div></div>
      <div class="legend-item"><div class="legend-emoji">üî±</div><div>Spread Boost</div></div>
    </div>

    <div style="margin-top:14px;font-size:14px;color:#ddd">Bullets are blocked by obstacles ‚Äî use cover!</div>
  </div>
</div>

<div id="gameover" style="display:none">
  <div class="menu-panel">
    <h1>Game Over</h1>
    <div id="finalScore" style="margin:8px 0">Score: 0</div>
    <div style="margin-top:12px">
      <button class="big-btn" onclick="restartGame()">Restart</button>
      <button class="big-btn" onclick="backToMenu()">Back to Menu</button>
    </div>
  </div>
</div>

<div class="js-visual" id="jsVisual"></div>

<script>
/* ======= Arena Shooter V10.5 (Final) =======
   Changes vs 10.4:
   - Enemy projectiles (blocked by obstacles).
   - Gun pickups (Pistol/Shotgun/Rifle/Rocket). Current gun shown in HUD.
   - Bullets DO NOT pass through obstacles (no ricochet; they stop).
   - Kept: pause button, haptics, minimap, power-ups, iPad joysticks, menu bindings.
   ------------------------------------------------------------ */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const minimapCanvas = document.getElementById('minimap');
const mm = minimapCanvas.getContext('2d');
const pauseBtn = document.getElementById('pauseBtn');

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  minimapCanvas.width = Math.min(180, Math.floor(innerWidth * 0.18));
  minimapCanvas.height = Math.min(130, Math.floor(innerHeight * 0.12));
  leftStick.x = 110; leftStick.y = canvas.height - 110;
  rightStick.x = canvas.width - 110; rightStick.y = canvas.height - 110;
}
addEventListener('resize', resize);

const arena = { width: 3000, height: 2000 };

let gameState = 'menu'; // menu, playing, paused, gameover
let gameMode = 'survival';
let timer = 90;
let score = 0;
let difficultyTime = 0;

const player = { x: arena.width/2, y: arena.height/2, r: 20, color:'#4da6ff', speed:3.2, health:100, flash:0 };

let bullets = [];       // player bullets
let enemyBullets = [];  // enemy bullets
let enemies = [];
let powerUps = [];
let gunPickups = [];
let obstacles = [];

const leftStick = { x:110, y:innerHeight-110, r:56, dx:0, dy:0, id:null };
const rightStick = { x:innerWidth-110, y:innerHeight-110, r:56, dx:0, dy:0, id:null, active:false, lastShot:0 };

const powerUpTypes = ['rapid','shield','double','speed','heal','explosive','spread'];

let rapidFire = 0, doublePoints = 0, speedBoost = 0, explosive = false, spreadBoost = false;

const jsVisual = document.getElementById('jsVisual');

(function createObstacles(){
  const shapes = ['rect','circle','triangle'];
  for (let i=0;i<55;i++){
    const shape = shapes[Math.floor(Math.random()*shapes.length)];
    const x = Math.random()*(arena.width-160)+80;
    const y = Math.random()*(arena.height-160)+80;
    if (shape === 'rect'){
      obstacles.push({shape:'rect', x:x, y:y, w:80 + Math.random()*80, h:50 + Math.random()*120});
    } else if (shape === 'circle'){
      obstacles.push({shape:'circle', x:x, y:y, r:30 + Math.random()*40});
    } else {
      obstacles.push({shape:'triangle', x:x, y:y, r:30 + Math.random()*40});
    }
  }
})();

/* ---------- Guns ---------- */
const guns = {
  pistol:  { name:'Pistol',  fireRate:300, bulletSpeed:10, damage:1, spreadCount:1, spreadAngle:0, radius:6, color:'#ffd43b', aoe:0 },
  shotgun: { name:'Shotgun', fireRate:450, bulletSpeed:9,  damage:1, spreadCount:5, spreadAngle:0.28, radius:6, color:'#ffe08a', aoe:0 },
  rifle:   { name:'Rifle',   fireRate:120, bulletSpeed:12, damage:1, spreadCount:1, spreadAngle:0, radius:5, color:'#b4d1ff', aoe:0 },
  rocket:  { name:'Rocket',  fireRate:700, bulletSpeed:7.5,damage:2, spreadCount:1, spreadAngle:0, radius:7, color:'#ff6b6b', aoe:90 }
};
let currentGun = guns.pistol;

function setGun(g){ currentGun = g; document.getElementById('gun').innerText = 'Gun: ' + g.name; vibrate(25); }
function spawnGunPickup(){
  const keys = Object.keys(guns);
  const key = keys[Math.floor(Math.random()*keys.length)];
  const type = key;
  gunPickups.push({
    x: Math.random()*(arena.width-80)+40,
    y: Math.random()*(arena.height-80)+40,
    r:16,
    type
  });
}

/* ---------- helpers ---------- */
function vibrate(ms){ try{ if (navigator.vibrate) navigator.vibrate(ms); }catch(_){} }

function circleRectCollision(cx,cy,cr, rx,ry,rw,rh){
  const closestX = Math.max(rx, Math.min(cx, rx+rw));
  const closestY = Math.max(ry, Math.min(cy, ry+rh));
  const dx = cx - closestX;
  const dy = cy - closestY;
  return dx*dx + dy*dy < cr*cr;
}
function circleCircleCollision(aX,aY,aR, bX,bY,bR){
  const d = Math.hypot(aX-bX, aY-bY);
  return d < (aR + bR);
}
function circleTriangleCollision(cx,cy,cr, tx,ty,tr){
  return Math.abs(cx - tx) < (tr + cr) && Math.abs(cy - ty) < (tr + cr);
}
function bulletHitsObstacle(bx,by,br){
  for (const ob of obstacles){
    if (ob.shape==='rect'){
      if (circleRectCollision(bx,by,br, ob.x-ob.w/2, ob.y-ob.h/2, ob.w, ob.h)) return true;
    } else if (ob.shape==='circle'){
      if (circleCircleCollision(bx,by,br, ob.x,ob.y,ob.r)) return true;
    } else {
      if (circleTriangleCollision(bx,by,br, ob.x,ob.y,ob.r)) return true;
    }
  }
  return false;
}
function clampToArena(ent){
  const rr = ent.r || 0;
  ent.x = Math.max(rr, Math.min(arena.width - rr, ent.x));
  ent.y = Math.max(rr, Math.min(arena.height - rr, ent.y));
}
function attemptMove(entity, nextX, nextY){
  let canX = true, canY = true;
  for (const ob of obstacles){
    if (ob.shape === 'rect'){
      if (circleRectCollision(nextX, entity.y, entity.r, ob.x - ob.w/2, ob.y - ob.h/2, ob.w, ob.h)) canX = false;
      if (circleRectCollision(entity.x, nextY, entity.r, ob.x - ob.w/2, ob.y - ob.h/2, ob.w, ob.h)) canY = false;
    } else if (ob.shape === 'circle'){
      if (circleCircleCollision(nextX, entity.y, entity.r, ob.x, ob.y, ob.r)) canX = false;
      if (circleCircleCollision(entity.x, nextY, entity.r, ob.x, ob.y, ob.r)) canY = false;
    } else {
      if (circleTriangleCollision(nextX, entity.y, entity.r, ob.x, ob.y, ob.r)) canX = false;
      if (circleTriangleCollision(entity.x, nextY, entity.r, ob.x, ob.y, ob.r)) canY = false;
    }
    if (!canX && !canY) break;
  }
  if (canX) entity.x = nextX;
  if (canY) entity.y = nextY;
  clampToArena(entity);
}

/* ---------- spawns & difficulty ---------- */
let waveTimerId = null;
function spawnEnemy(nearPlayerBias = 1.0){
  const side = Math.floor(Math.random()*4);
  let x,y;
  const margin = 120 + Math.random()*220*nearPlayerBias;
  if (side === 0){ x = player.x + margin; y = player.y + (Math.random()-0.5)*600; }
  else if (side === 1){ x = player.x - margin; y = player.y + (Math.random()-0.5)*600; }
  else if (side === 2){ x = player.x + (Math.random()-0.5)*800; y = player.y + margin; }
  else { x = player.x + (Math.random()-0.5)*800; y = player.y - margin; }
  x = Math.max(40, Math.min(arena.width-40, x));
  y = Math.max(40, Math.min(arena.height-40, y));

  const t = (Math.random() < (0.55 + Math.min(0.25, difficultyTime/1800))) ? 'fast' : 'slow';
  const bonusHP = Math.floor(difficultyTime/60) % 5;
  const health = t === 'fast' ? 1 : 6 + Math.floor(Math.random()*4) + bonusHP;
  const dmg = t === 'fast' ? 4 + Math.floor(difficultyTime/120) : 12 + Math.floor(difficultyTime/90);
  // enemy shooting params
  const fireRate = (t==='fast') ? 900 : 1200; // ms
  const bulletSpeed = (t==='fast') ? 8.5 : 7;
  enemies.push({ x,y, type:t, r: t==='fast'?10:30, color: t==='fast'?'#ff6b6b':'#9e2a2b',
                 health, maxHealth:health, lastHit:0, damage:dmg,
                 lastShot:0, fireRate, bulletSpeed, range: 800 });
}
function spawnPowerUp(){
  const type = powerUpTypes[Math.floor(Math.random()*powerUpTypes.length)];
  powerUps.push({ x: Math.random()*(arena.width-80)+40, y: Math.random()*(arena.height-80)+40, r:16, type, duration: 800 });
}
function startWaves(){
  for (let i=0;i<4;i++) spawnEnemy(0.8);
  if (waveTimerId) clearInterval(waveTimerId);
  waveTimerId = setInterval(()=>{
    if (gameState==='playing'){
      const extra = Math.min(6, Math.floor(difficultyTime/25));
      for(let i=0;i<4+extra;i++) spawnEnemy(1.2);
      // occasionally drop a gun
      if (Math.random() < 0.6) spawnGunPickup();
    }
  }, 4500);
}

/* ---------- input (touch & mouse) ---------- */
canvas.addEventListener('touchstart', (ev)=>{
  for(const t of ev.changedTouches){
    const tx = t.clientX, ty = t.clientY;
    if (Math.hypot(tx - leftStick.x, ty - leftStick.y) <= leftStick.r) leftStick.id = t.identifier;
    if (Math.hypot(tx - rightStick.x, ty - rightStick.y) <= rightStick.r) { rightStick.id = t.identifier; rightStick.active = true; }
  }
});
canvas.addEventListener('touchmove', (ev)=>{
  ev.preventDefault();
  for(const t of ev.changedTouches){
    const tx = t.clientX, ty = t.clientY;
    if (t.identifier === leftStick.id){
      leftStick.dx = tx - leftStick.x; leftStick.dy = ty - leftStick.y;
      let d = Math.hypot(leftStick.dx, leftStick.dy);
      if (d > leftStick.r) { leftStick.dx = leftStick.dx/d*leftStick.r; leftStick.dy = leftStick.dy/d*leftStick.r; }
    }
    if (t.identifier === rightStick.id){
      rightStick.dx = tx - rightStick.x; rightStick.dy = ty - rightStick.y;
      let d = Math.hypot(rightStick.dx, rightStick.dy);
      if (d > rightStick.r) { rightStick.dx = rightStick.dx/d*rightStick.r; rightStick.dy = rightStick.dy/d*rightStick.r; }
    }
  }
});
canvas.addEventListener('touchend', (ev)=>{
  for(const t of ev.changedTouches){
    if (t.identifier === leftStick.id){ leftStick.id = null; leftStick.dx = 0; leftStick.dy = 0; }
    if (t.identifier === rightStick.id){ rightStick.id = null; rightStick.dx = 0; rightStick.dy = 0; rightStick.active = false; }
  }
});
let mouseDownLeft=false, mouseDownRight=false;
canvas.addEventListener('mousedown', (e)=>{
  const x=e.clientX, y=e.clientY;
  if (x < innerWidth*0.6){ mouseDownLeft = true; leftStick.dx = x - leftStick.x; leftStick.dy = y - leftStick.y; }
  else { mouseDownRight = true; rightStick.active = true; rightStick.dx = x - rightStick.x; rightStick.dy = y - rightStick.y; }
});
canvas.addEventListener('mousemove', (e)=>{
  if (mouseDownLeft){
    leftStick.dx = e.clientX - leftStick.x; leftStick.dy = e.clientY - leftStick.y;
    let d=Math.hypot(leftStick.dx,leftStick.dy);
    if(d>leftStick.r){leftStick.dx=leftStick.dx/d*leftStick.r;leftStick.dy=leftStick.dy/d*leftStick.r;}
  }
  if (mouseDownRight){
    rightStick.dx = e.clientX - rightStick.x; rightStick.dy = e.clientY - rightStick.y;
    let d=Math.hypot(rightStick.dx,rightStick.dy);
    if(d>rightStick.r){rightStick.dx=rightStick.dx/d*rightStick.r;rightStick.dy=rightStick.dy/d*rightStick.r;}
  }
});
addEventListener('mouseup', ()=>{
  mouseDownLeft=false; mouseDownRight=false;
  leftStick.dx=0; leftStick.dy=0; rightStick.dx=0; rightStick.dy=0; rightStick.active=false;
});

/* ---------- core update ---------- */
let lastFrame = performance.now();
function firePlayer(angle){
  const now = Date.now();
  const fireBoost = (rapidFire>0) ? 0.6 : 1;
  const fireRate = currentGun.fireRate * fireBoost;
  if (rightStick.lastShot && now - rightStick.lastShot < fireRate) return;
  rightStick.lastShot = now;

  const spreadN = currentGun.spreadCount + (spreadBoost?2:0);
  const total = spreadN;
  const base = angle;
  const spread = currentGun.spreadAngle;
  for (let i=0;i<total;i++){
    const a = base + (total>1 ? (i-(total-1)/2)*spread : 0);
    const dx = Math.cos(a)*currentGun.bulletSpeed;
    const dy = Math.sin(a)*currentGun.bulletSpeed;
    bullets.push({
      x: player.x + Math.cos(a)*player.r,
      y: player.y + Math.sin(a)*player.r,
      dx, dy,
      r: currentGun.radius,
      life: 260,
      color: currentGun.color,
      damage: currentGun.damage,
      aoe: currentGun.aoe
    });
  }
}

function update(dt){
  if (gameState !== 'playing') return;

  difficultyTime += dt/1000;

  // movement
  const ldx = leftStick.dx, ldy = leftStick.dy;
  const lmag = Math.hypot(ldx,ldy);
  if (lmag > 8){
    const s = player.speed * (speedBoost>0?1.45:1.0);
    const nx = player.x + (ldx / lmag) * s;
    const ny = player.y + (ldy / lmag) * s;
    attemptMove(player, nx, ny);
  }

  // shooting by player
  if (rightStick.active){
    const rdx = rightStick.dx, rdy = rightStick.dy;
    const rmag = Math.hypot(rdx,rdy);
    if (rmag > 6){
      const angle = Math.atan2(rdy, rdx);
      firePlayer(angle);
    }
  }

  // --- player bullets ---
  for (let i = bullets.length-1; i>=0; i--){
    const b = bullets[i];
    const nx = b.x + b.dx;
    const ny = b.y + b.dy;

    // check obstacle FIRST; if will hit, stop bullet there
    if (bulletHitsObstacle(nx, ny, b.r)){
      // AOE if rocket
      if (b.aoe>0){
        for (let j=enemies.length-1;j>=0;j--){
          const e = enemies[j];
          if (Math.hypot(e.x - b.x, e.y - b.y) <= b.aoe){
            e.health -= 2;
            if (e.health <= 0){ score += (doublePoints>0)?2:1; enemies.splice(j,1); }
          }
        }
      }
      bullets.splice(i,1);
      continue;
    }

    b.x = nx; b.y = ny;
    b.life -= dt;
    if (b.x < 0 || b.x > arena.width || b.y < 0 || b.y > arena.height || b.life <= 0){
      bullets.splice(i,1); continue;
    }

    // hit enemy
    for (let j = enemies.length-1; j>=0; j--){
      const e = enemies[j];
      if (Math.hypot(e.x - b.x, e.y - b.y) < e.r + b.r){
        e.health -= b.damage;
        if (b.aoe>0){
          for (let k=enemies.length-1;k>=0;k--){
            const e2 = enemies[k];
            const d2 = Math.hypot(e2.x - b.x, e2.y - b.y);
            if (d2 < b.aoe) e2.health -= b.damage;
          }
        }
        bullets.splice(i,1);
        if (e.health <= 0){
          score += (doublePoints>0) ? 2 : 1;
          enemies.splice(j,1);
          vibrate(12);
        }
        break;
      }
    }
  }

  // --- enemy AI + shooting ---
  const now = Date.now();
  for (const e of enemies){
    // move toward player
    const ang = Math.atan2(player.y - e.y, player.x - e.x);
    const base = (e.type==='fast')?3.2:1.3;
    const spd = base + Math.min(1.5, difficultyTime/1200);
    const ex = e.x + Math.cos(ang) * spd;
    const ey = e.y + Math.sin(ang) * spd;
    attemptMove(e, ex, ey);

    // melee contact
    if (Math.hypot(player.x - e.x, player.y - e.y) < player.r + e.r + 2){
      if (!e.lastHit || now - e.lastHit > 600){
        player.health -= e.damage; e.lastHit = now; player.flash = 10; vibrate(30);
        if (player.health <= 0){ player.health = 0; endGame(); }
      }
    }

    // ranged attack
    const dist = Math.hypot(player.x - e.x, player.y - e.y);
    if (dist < e.range && (!e.lastShot || now - e.lastShot >= e.fireRate)){
      // shoot toward player
      const a = Math.atan2(player.y - e.y, player.x - e.x);
      const dx = Math.cos(a)*e.bulletSpeed, dy = Math.sin(a)*e.bulletSpeed;
      enemyBullets.push({ x:e.x + Math.cos(a)*e.r, y:e.y + Math.sin(a)*e.r, dx, dy, r:5, life:260, color:'#ff9aa2', damage:8 });
      e.lastShot = now;
    }
  }

  // --- enemy bullets ---
  for (let i = enemyBullets.length-1; i>=0; i--){
    const b = enemyBullets[i];
    const nx = b.x + b.dx, ny = b.y + b.dy;

    // obstacle stops enemy bullet too
    if (bulletHitsObstacle(nx, ny, b.r)){
      enemyBullets.splice(i,1); continue;
    }

    b.x = nx; b.y = ny;
    b.life -= dt;
    if (b.x < 0 || b.x > arena.width || b.y < 0 || b.y > arena.height || b.life <= 0){
      enemyBullets.splice(i,1); continue;
    }

    // hit player
    if (Math.hypot(player.x - b.x, player.y - b.y) < player.r + b.r){
      player.health -= b.damage;
      player.flash = 10; vibrate(25);
      enemyBullets.splice(i,1);
      if (player.health <= 0){ player.health = 0; endGame(); }
    }
  }

  // power-ups
  for (let i=powerUps.length-1;i>=0;i--){
    const p = powerUps[i];
    if (Math.hypot(player.x - p.x, player.y - p.y) < player.r + p.r){
      applyPowerUp(p.type);
      powerUps.splice(i,1); vibrate(18);
    }
  }

  // gun pickups
  for (let i=gunPickups.length-1;i>=0;i--){
    const g = gunPickups[i];
    if (Math.hypot(player.x - g.x, player.y - g.y) < player.r + g.r){
      setGun(guns[g.type]); gunPickups.splice(i,1);
    }
  }

  // buffs decay & timer
  if (rapidFire>0) rapidFire--;
  if (doublePoints>0) doublePoints--;
  if (speedBoost>0) speedBoost--;
  if (gameMode === 'time') {
    timer -= dt / 1000;
    if (timer <= 0) endGame();
  }
}

function applyPowerUp(type){
  switch(type){
    case 'rapid': rapidFire = 300; break;
    case 'shield': player.health = Math.min(100, player.health + 45); break;
    case 'double': doublePoints = 300; break;
    case 'speed': speedBoost = 300; break;
    case 'heal': player.health = Math.min(100, player.health + 30); break;
    case 'explosive': explosive = true; setTimeout(()=>explosive=false,5000); break;
    case 'spread': spreadBoost = true; setTimeout(()=>spreadBoost=false,5000); break;
  }
}

/* ---------- drawing ---------- */
function drawScene(){
  ctx.fillStyle = '#0c0c0f';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const camX = Math.min(Math.max(player.x - canvas.width/2, 0), arena.width - canvas.width);
  const camY = Math.min(Math.max(player.y - canvas.height/2, 0), arena.height - canvas.height);

  ctx.save();
  ctx.translate(-camX, -camY);

  // obstacles
  for (const ob of obstacles){
    ctx.fillStyle = '#444';
    if (ob.shape === 'rect'){
      ctx.fillRect(ob.x - ob.w/2, ob.y - ob.h/2, ob.w, ob.h);
    } else if (ob.shape === 'circle'){
      ctx.beginPath(); ctx.arc(ob.x, ob.y, ob.r, 0, Math.PI*2); ctx.fill();
    } else {
      ctx.beginPath(); ctx.moveTo(ob.x, ob.y - ob.r); ctx.lineTo(ob.x - ob.r, ob.y + ob.r); ctx.lineTo(ob.x + ob.r, ob.y + ob.r); ctx.closePath(); ctx.fill();
    }
  }

  // bullets (player)
  for (const b of bullets){
    ctx.fillStyle = b.color;
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
    if (b.aoe>0){
      ctx.globalAlpha = 0.08;
      ctx.beginPath(); ctx.arc(b.x, b.y, b.aoe, 0, Math.PI*2); ctx.fillStyle = '#ff6b6b'; ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // bullets (enemy)
  for (const b of enemyBullets){
    ctx.fillStyle = b.color;
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
  }

  // enemies
  for (const e of enemies){
    ctx.fillStyle = e.color;
    if (e.type === 'fast'){
      ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill();
    } else {
      ctx.beginPath(); ctx.moveTo(e.x, e.y - e.r); ctx.lineTo(e.x - e.r, e.y + e.r); ctx.lineTo(e.x + e.r, e.y + e.r); ctx.closePath(); ctx.fill();
      if (e.health < e.maxHealth){
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(e.x - e.r, e.y - e.r - 12, e.r*2, 6);
        ctx.fillStyle = '#3be07a';
        ctx.fillRect(e.x - e.r, e.y - e.r - 12, (e.health / e.maxHealth) * e.r * 2, 6);
      }
    }
  }

  // powerups (emoji)
  ctx.font = '22px serif';
  for (const p of powerUps){
    let emoji = '‚ö°';
    if (p.type==='shield') emoji='üõ°'; else if (p.type==='double') emoji='‚ú¶';
    else if (p.type==='speed') emoji='üèÉ'; else if (p.type==='heal') emoji='üíñ';
    else if (p.type==='explosive') emoji='üí•'; else if (p.type==='spread') emoji='üî±';
    ctx.fillText(emoji, p.x - 8, p.y + 8);
  }

  // gun pickups (simple colored dots + label)
  for (const g of gunPickups){
    let c = '#fff', label='üî´';
    if (g.type==='shotgun'){ c='#b388ff'; label='üü£'; }
    else if (g.type==='rifle'){ c='#6ab4ff'; label='üîµ'; }
    else if (g.type==='rocket'){ c='#ff6b6b'; label='üü•'; }
    ctx.fillStyle = c; ctx.beginPath(); ctx.arc(g.x, g.y, g.r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.fillText(label, g.x-7, g.y+7);
  }

  // player
  ctx.fillStyle = player.flash>0 ? '#ffffff' : player.color;
  if (player.flash>0) player.flash--;
  ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill();

  // aim arrow
  if (rightStick.active){
    const rx = rightStick.dx, ry = rightStick.dy;
    const mag = Math.hypot(rx,ry);
    if (mag > 6){
      const angle = Math.atan2(ry, rx);
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.rotate(angle);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(40,0); ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.moveTo(46,0); ctx.lineTo(34,-6); ctx.lineTo(34,6); ctx.closePath(); ctx.fill();
      ctx.restore();
    }
  }

  ctx.restore();

  // HUD
  document.getElementById('health-fill').style.width = Math.max(0, player.health) + '%';
  document.getElementById('score').innerText = 'Score: ' + score;
  document.getElementById('timer').innerText = gameMode === 'time' ? ('Time: ' + Math.max(0, Math.ceil(timer))) : '';
}

/* ---------- minimap ---------- */
function drawMinimap(){
  mm.clearRect(0,0,minimapCanvas.width,minimapCanvas.height);
  mm.fillStyle = '#080808';
  mm.fillRect(0,0,minimapCanvas.width,minimapCanvas.height);
  const sx = minimapCanvas.width / arena.width;
  const sy = minimapCanvas.height / arena.height;

  mm.fillStyle = '#444';
  for (const ob of obstacles){
    mm.fillRect(Math.floor(ob.x * sx) - 1, Math.floor(ob.y * sy) - 1, 3, 3);
  }
  mm.fillStyle = '#ffd54f';
  for (const p of powerUps){
    mm.fillRect(Math.floor(p.x * sx)-1, Math.floor(p.y * sy)-1, 3, 3);
  }
  mm.fillStyle = '#a0e0ff';
  for (const g of gunPickups){
    mm.fillRect(Math.floor(g.x*sx)-1, Math.floor(g.y*sy)-1, 3,3);
  }
  for (const e of enemies){
    mm.fillStyle = e.type === 'fast' ? '#ff6b6b' : '#8b1f2b';
    const ex = Math.floor(e.x * sx), ey = Math.floor(e.y * sy);
    if (e.type === 'fast'){ mm.beginPath(); mm.arc(ex, ey, 2, 0, Math.PI*2); mm.fill(); }
    else { mm.beginPath(); mm.moveTo(ex, ey-3); mm.lineTo(ex-3, ey+3); mm.lineTo(ex+3, ey+3); mm.closePath(); mm.fill(); }
  }
  mm.fillStyle = '#4da6ff';
  mm.fillRect(Math.floor(player.x * sx)-2, Math.floor(player.y * sy)-2, 4, 4);
}

/* ---------- main loop ---------- */
let running = true;
function mainLoop(ts){
  const dt = Math.min(40, ts - lastFrame);
  lastFrame = ts;

  if (gameState === 'playing') {
    update(dt);
    drawScene();
    drawMinimap();
  }
  if (running) requestAnimationFrame(mainLoop);
}

/* ---------- control (exposed) ---------- */
function _startGame(mode){
  gameMode = mode || 'survival';
  timer = (gameMode==='time') ? 60 : 9999;
  score = 0;
  bullets = []; enemyBullets = []; enemies = []; powerUps = []; gunPickups = [];
  player.x = arena.width/2; player.y = arena.height/2; player.health=100; player.flash=0;
  rapidFire = doublePoints = speedBoost = 0; explosive=false; spreadBoost=false;
  difficultyTime = 0;
  setGun(guns.pistol);

  document.getElementById('menu').style.display = 'none';
  document.getElementById('gameover').style.display = 'none';
  gameState = 'playing';
  startWaves();
  for (let i=0;i<3;i++) spawnPowerUp();
  for (let i=0;i<2;i++) spawnGunPickup();
  vibrate(20);
}
function endGame(){
  gameState = 'gameover';
  document.getElementById('finalScore').innerText = 'Score: ' + score;
  document.getElementById('gameover').style.display = 'flex';
  if (waveTimerId) { clearInterval(waveTimerId); waveTimerId = null; }
}
function _backToMenu(){
  document.getElementById('menu').style.display = 'flex';
  document.getElementById('gameover').style.display = 'none';
  gameState = 'menu';
}
function _restartGame(){
  document.getElementById('gameover').style.display = 'none';
  _startGame(gameMode);
}
function _togglePause(){
  if (gameState === 'playing'){ gameState = 'paused'; pauseBtn.textContent = 'Resume'; }
  else if (gameState === 'paused'){ gameState = 'playing'; pauseBtn.textContent = 'Pause'; }
}
/* bindings for buttons */
window.startGame = _startGame;
window.backToMenu = _backToMenu;
window.restartGame = _restartGame;

pauseBtn.addEventListener('click', _togglePause);

/* ---------- boot ---------- */
resize();
requestAnimationFrame(mainLoop);

/* joystick visuals (optional) */
function updateJSVisual(){
  jsVisual.innerHTML = '';
  const createCircle = (cx, cy, r, knobX, knobY) => {
    const wrap = document.createElement('div');
    wrap.className = 'js-circle';
    wrap.style.left = cx + 'px';
    wrap.style.top = cy + 'px';
    wrap.style.width = (r*2) + 'px';
    wrap.style.height = (r*2) + 'px';
    const knob = document.createElement('div');
    knob.className='js-knob';
    knob.style.transform = `translate(${knobX - cx}px, ${knobY - cy}px)`;
    wrap.appendChild(knob);
    jsVisual.appendChild(wrap);
  };
  createCircle(leftStick.x, leftStick.y, leftStick.r, leftStick.x + leftStick.dx, leftStick.y + leftStick.dy);
  createCircle(rightStick.x, rightStick.y, rightStick.r, rightStick.x + rightStick.dx, rightStick.y + rightStick.dy);
}
setInterval(updateJSVisual, 80);

/* periodic spawns */
setInterval(()=>{
  if (gameState==='playing' && Math.random() < 0.6) spawnPowerUp();
  if (gameState==='playing' && Math.random() < 0.4) spawnGunPickup();
}, 8000);

/* keep canvas focused for touch */
canvas.addEventListener('touchstart', ()=>{ canvas.focus(); }, {passive:true});

/* debug keys */
addEventListener('keydown', (e)=>{
  if (e.key === 'm') { if (gameState === 'menu') _startGame('survival'); else _backToMenu(); }
  if (e.key === 'r') _restartGame();
  if (e.key === 'p') _togglePause();
});

console.log('Arena Shooter V10.5 ‚Äî bullets blocked by obstacles, enemies shoot back, gun pickups enabled.');
</script>
</body>
</html>
